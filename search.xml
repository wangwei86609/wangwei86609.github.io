<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式</title>
      <link href="/2024/03/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2024/03/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Compiler-Design-Regular-Expressions"><a href="#Compiler-Design-Regular-Expressions" class="headerlink" title="Compiler Design - Regular Expressions"></a>Compiler Design - Regular Expressions</h1><p>The lexical analyzer needs to scan and identify only a finite set of valid string/token/lexeme that belong to the language in hand. It searches for the pattern defined by the language rules.<br>Regular expressions have the capability to express finite languages by defining a pattern for finite strings of symbols. The grammar defined by regular expressions is known as regular grammar. The language defined by regular grammar is known as regular language.<br>Regular expression is an important notation for specifying patterns. Each pattern matches a set of strings, so regular expressions serve as names for a set of strings. Programming language tokens can be described by regular languages. The specification of regular expressions is an example of a recursive definition. Regular languages are easy to understand and have efficient implementation.<br>There are a number of algebraic laws that are obeyed by regular expressions, which can be used to manipulate regular expressions into equivalent forms.</p><h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2><p>The various operations on languages are:</p><ul><li>Union of two languages L and M is written as L U M = {s | s is in L or s is in M}</li><li>Concatenation of two languages L and M is written as LM = {st | s is in L and t is in M}</li><li>The Kleene Closure of a language L is written as L* = Zero or more occurrence of language L.</li></ul><h2 id="Notations"><a href="#Notations" class="headerlink" title="Notations"></a>Notations</h2><p>If r and s are regular expressions denoting the languages L(r) and L(s), then</p><ul><li>Union : (r)|(s) is a regular expression denoting L(r) U L(s)</li><li>Concatenation : (r)(s) is a regular expression denoting L(r)L(s)</li><li>Kleene closure : (r)<em> is a regular expression denoting (L(r))</em></li><li>(r) is a regular expression denoting L(r)<h2 id="Precedence-and-Associativity"><a href="#Precedence-and-Associativity" class="headerlink" title="Precedence and Associativity"></a>Precedence and Associativity</h2></li><li>*, concatenation (.), and | (pipe sign) are left associative</li><li><ul><li>has the highest precedence</li></ul></li><li>Concatenation (.) has the second highest precedence.</li><li>|(pipe sign) has the lowest precedence of all.</li></ul><h2 id="Representing-valid-tokens-of-a-language-in-regular-expression"><a href="#Representing-valid-tokens-of-a-language-in-regular-expression" class="headerlink" title="Representing valid tokens of a language in regular expression"></a>Representing valid tokens of a language in regular expression</h2><p>If x is a regular expression, then:</p><ul><li>x* means zero or more occurrence of x. i.e., it can generate { e, x, xx, xxx, xxxx, … }</li><li>x+ means one or more occurrence of x. i.e., it can generate { x, xx, xxx, xxxx … } or x.x*</li><li>x? means at most one occurrence of x i.e., it can generate either {x} or {e}.</li><li>[a-z] is all lower-case alphabets of English language.</li><li>[A-Z] is all upper-case alphabets of English language.</li><li>[0-9] is all natural digits used in mathematics.</li></ul><h2 id="Representing-occurrence-of-symbols-using-regular-expressions"><a href="#Representing-occurrence-of-symbols-using-regular-expressions" class="headerlink" title="Representing occurrence of symbols using regular expressions"></a>Representing occurrence of symbols using regular expressions</h2><p>letter = [a – z] or [A – Z]<br>digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 or [0-9]<br>sign = [ + | - ]</p><h2 id="Representing-language-tokens-using-regular-expressions"><a href="#Representing-language-tokens-using-regular-expressions" class="headerlink" title="Representing language tokens using regular expressions"></a>Representing language tokens using regular expressions</h2><p>Decimal = (sign)?(digit)+<br>Identifier = (letter)(letter | digit)*<br>The only problem left with the lexical analyzer is how to verify the validity of a regular expression used in specifying the patterns of keywords of a language. A well-accepted solution is to use finite automata for verification.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
